local Lucid = {};
Lucid.Settings = { Interface = { Toggle_key = Enum.KeyCode.Insert; Dark_mode = true; Theme_options = { 'Dark'; 'Light'; }; Cross_hair_types = { 'Cross'; 'Circle'; }; }; Visuals = { Enabled = true; Check_visibility = true; Cross_hair = false; Show_teams = false; Show_tracers = false; Tracer_origin_point = 'Center'; Show_names = false; Show_distance = false; Show_boxes = false; Show_head_dot = false; Text_size = 50; Render_distance = 2750; Cross_hair_size = Vector2.new(1, 1); Cross_hair_thickness = .1; Cross_hair_type = 'Cross'; Colors = { Cross_hair = Color3.fromRGB(255, 255, 255); Enemy = Color3.fromRGB(255, 0, 0); Team = Color3.fromRGB(0, 255, 0); }; }; Characters = { Rig_type = 'R15'; Rig_parts = {}; }; Aim_bot = { Enabled = true; Bullet_drop = true; Bullet_speed = 2650; Free_for_all = false; Check_visibility = true; Aiming_down = false; Aim_offset = Vector3.new(0, 1.5, 0); Sensitivity = { Min = 0; Current = 50; Max = 100; }; Aim_at = 'PrimaryPart'; }; };
Lucid.Interface = {};

--// Services: Retrieve services within the game. \\--

Lucid.Services = setmetatable({}, {
    __index = function(_, Service_name)
        local Success, Service = pcall(game.GetService, game, Service_name);

        if Success then
            return Service;
        end;
    end;
});

--// Instance: Responsible for creating new objects into the game. \\--

function Lucid:Instance(Class_name)
    local New_class = {};
    New_class.Instance = Instance.new(Class_name);

    function New_class:Modify(Property, Value)
        self.Instance[Property] = Value;
    end;

    function New_class:Descend(Descendants)
        local Last_descendant;

        Descendants = Descendants or {};

        for Descend_class_name, Descend_options in pairs(Descendants) do
            Descend_class_name = string.gsub(Descend_class_name, '%d', '');
            Last_descendant = Lucid:Instance(Descend_class_name);
            Last_descendant:Modify('Parent', self.Instance);

            for Option, Arguments in pairs(Descend_options) do
                Last_descendant[Option](Last_descendant, unpack(Arguments));
            end;
        end;

        return Last_descendant;
    end;

    function New_class:Destroy()
        self.Instance:Destroy();
        self = nil;
    end;

    function New_class:Remove()
        self.Instance:Remove();
        self = nil;
    end;

    return New_class;
end;

--// Player: Returns the client from players. \\--

function Lucid:Player()
    local Players = self.Services.Players;

    return Players.LocalPlayer;
end;

--// Mouse: Returns the mouse from client. \\--

function Lucid:Mouse()
    local Player = self:Player();

    return Player:GetMouse();
end;

--// Camera: Returns the clients camera. \\--

function Lucid:Camera()
    local Workspace = self.Services.Workspace;

    return Workspace.CurrentCamera;
end;

--// Character: Returns the character form player. \\--

function Lucid:Character()
    local Player = self:Player();

    return Player.Character or Player.CharacterAdded:Wait();
end;

--// Humanoid: Returns the humanoid from the character. \\--

function Lucid:Humanoid()
    local Character = self:Character();

    return Character:FindFirstChildOfClass('Humanoid');
end;

--// Game_Sync: Awaits the game to load completely. \\--

function Lucid:Game_synced()
    repeat wait()

    until (game:IsLoaded()) and (self:Player() ~= nil);
end;

--// Environment: Returns a table of all required utilities. \\--

function Lucid:Environment()
    local Environment = {
        Io = {
            Append_file = appendfile or syn_io_append or warn(string.format('Your exploit isn\'t compatible your missing %s', 'Append_file [appendfile]'));
            Delete_file = delfile or syn_io_delfile or warn(string.format('Your exploit isn\'t compatible your missing %s', 'Delete_file [delfile]'));
            Delete_folder = delfolder or syn_io_delfolder or warn(string.format('Your exploit isn\'t compatible your missing %s', 'Delete_folder [delfolder]'));
            Is_file = isfile or syn_io_isfile or warn(string.format('Your exploit isn\'t compatible your missing %s', 'Is_file [isfile]'));
            Is_folder = isfolder or syn_io_isfolder or warn(string.format('Your exploit isn\'t compatible your missing %s', 'Is_folder [isfolder]'));
            List_dir = listfiles or syn_io_listdir or warn(string.format('Your exploit isn\'t compatible your missing %s', 'List_dir [listfiles]'));
            Make_folder = makefolder or syn_io_makefolder or warn(string.format('Your exploit isn\'t compatible your missing %s', 'Make_folder [makefolder]'));
            Read_file = readfile or syn_io_read or warn(string.format('Your exploit isn\'t compatible your missing %s', 'Read_file [readfile]'));
            Write_file = writefile or syn_io_write or warn(string.format('Your exploit isn\'t compatible your missing %s', 'Write_file [writefile]'));
        };
        Drawing = {
            New = Drawing.new or warn(string.format('Your exploit isn\'t compatible your missing %s', 'New [Drawing.new]'));
        };
        Console = {
            Name = syn_console_name or rconsolename or warn(string.format('Your exploit isn\'t compatible your missing %s', 'Name [rconsolename]'));
            Clear = rconsoleclear or warn(string.format('Your exploit isn\'t compatible your missing %s', 'Clear [rconsoleclear]'));

            Info = syn_console_iprint or rconsoleinfo or warn(string.format('Your exploit isn\'t compatible your missing %s', 'Info [rconsoleinfo]'));
            Print = syn_console_print or rconsoleprint or warn(string.format('Your exploit isn\'t compatible your missing %s', 'Print [rconsoleprint]'));
            Warn = syn_console_wprint or rconsolewarn or warn(string.format('Your exploit isn\'t compatible your missing %s', 'Name [rconsolewarn]'));
            Error = syn_console_eprint or rconsoleerr or warn(string.format('Your exploit isn\'t compatible your missing %s', 'Name [rconsoleerr]'));
        };
        Scripts = {
            Get_thread_context = (syn and syn.get_thread_identity) or getthreadcontext or getcontext or warn(string.format('Your exploit isn\'t compatible your missing %s', 'Get_thread_context [get_thread_identity]'));
            Set_thread_context = (syn and syn.set_thread_identity) or setthreadcontext or setcontext or warn(string.format('Your exploit isn\'t compatible your missing %s', 'Set_thread_context [set_thread_identity]'));
            Check_caller = checkcaller or warn(string.format('Your exploit isn\'t compatible your missing %s', 'Check_caller [checkcaller]'));
            Get_calling = syn_getcallingscript or getcallingscript or get_calling_script or warn(string.format('Your exploit isn\'t compatible your missing %s', 'Get_calling [getcallingscript]'));
            Get_call_stack = getcallstack or warn(string.format('Your exploit isn\'t compatible your missing %s', 'Get_call_stack [getcallstack]'));
            Get_namecall_method = getnamecallmethod or warn(string.format('Your exploit isn\'t compatible your missing %s', 'Get_call_stack [getcallstack]'));
            Is_1_closure = islclosure or (iscclosure and function(closure) return not iscclosure(closure) end) or warn(string.format('Your exploit isn\'t compatible your missing %s', 'Is_1_closure [islclosure]'));
            Is_x_closure = is_synapse_function or is_protosmasher_closure or issentinelclosure or warn(string.format('Your exploit isn\'t compatible your missing %s', 'Is_x_closure [is_synapse_function]'));
        };
        Functions = {
            Set_readonly = setreadonly or make_writeable or warn(string.format('Your exploit isn\'t compatible your missing %s', 'Set_readonly [setreadonly]'));
            Get_metatable = getrawmetatable or debug.getmetatable or warn(string.format('Your exploit isn\'t compatible your missing %s', 'Get_metatable [getrawmetatable]'));
            New_closure = syn_newcclosure or newcclosure or warn(string.format('Your exploit isn\'t compatible your missing %s', 'New_closure [newcclosure]'));
            Hook = hookfunc or hookfunction or warn(string.format('Your exploit isn\'t compatible your missing %s', 'Hook [hookfunction]'));
        };
        Interactions = {
            Mouse = {
                Move_relative = syn_mousemoverel or mousemoverel or warn(string.format('Your exploit isn\'t compatible your missing %s', 'Move_relative [mousemoverel]'));
                Move_absolute = syn_mousemoveabs or mousemoveabs or warn(string.format('Your exploit isn\'t compatible your missing %s', 'Move_absolute [mousemoveabs]'));
                Scroll = syn_mousescroll or mousescroll or warn(string.format('Your exploit isn\'t compatible your missing %s', 'Scroll [mousescroll]'));
                Left_click = syn_mouse1click or mouse1click or warn(string.format('Your exploit isn\'t compatible your missing %s', 'Left_click [mouse1click]'));
                Right_click = syn_mouse2click or mouse2click or warn(string.format('Your exploit isn\'t compatible your missing %s', 'Right_click [mouse2click]'));
            };
            Keyboard = {
                Key_press = syn_keypress or keypress or warn(string.format('Your exploit isn\'t compatible your missing %s', 'Key_press [keypress]'));
                Key_release = syn_keyrelease or keyrelease or warn(string.format('Your exploit isn\'t compatible your missing %s', 'Key_press [keypress]'));
            };
        };
    };

    return Environment;
end;

--// Drawing: Responsible for creating new external ui elements. \\--

function Lucid:Drawing(Class_name)
    local New_class = {};
    local Environment = self:Environment();
    New_class.Instance = Environment.Drawing.New(Class_name);

    function New_class:Modify(Property, Value)
        self.Instance[Property] = Value;
    end;

    function New_class:Descend(Descendants)
        local Last_descendant;

        Descendants = Descendants or {};

        for Descend_class_name, Descend_options in pairs(Descendants) do
            Descend_class_name = string.gsub(Descend_class_name, '%d', '');
            Last_descendant = Lucid:Drawing(Descend_class_name);

            for Option, Arguments in pairs(Descend_options) do
                Last_descendant[Option](Last_descendant, unpack(Arguments));
            end;
        end;

        return Last_descendant;
    end;

    function New_class:Destroy()
        self.Instance:Remove();
        self = nil;
    end;

    function New_class:Remove()
        self.Instance:Remove();
        self = nil;
    end;

    return New_class;
end;

--// Get_rig: Returns the character aim parts. \\--

function Lucid:Get_rig()
    local Players = self.Services.Players;
    local Rig = {};

    wait(1);

    for _, Player in pairs(Players:GetPlayers()) do
        local Character = Player.Character;

        if Character then
            for _, Object in pairs(Character:GetChildren()) do
                if Object:IsA('BasePart') then
                    if Object.Name == 'Torso' then
                        self.Settings.Characters.Rig_type = Enum.HumanoidRigType.R6;

                        break;
                    elseif Object.Name == 'UpperTorso' then
                        self.Settings.Characters.Rig_type = Enum.HumanoidRigType.R15;

                        break;
                    end;
                end;
            end;

            if self.Settings.Characters.Rig_type == Enum.HumanoidRigType.R6 then
                Rig = { [1] = 'Head'; [2] = 'Torso'; [3] = 'PrimaryPart'; [4] = 'Left Arm'; [5] = 'Right Arm'; [6] = 'Left Leg'; [7] = 'Right Leg'; };
                self.Settings.Characters.Rig_parts = Rig;
            elseif self.Settings.Characters.Rig_type == Enum.HumanoidRigType.R15 then
                Rig = { [1] = 'Head'; [2] = 'UpperTorso'; [3] = 'PrimaryPart'; [4] = 'LeftUpperArm'; [5] = 'RightUpperArm'; [6] = 'LeftLowerArm'; [7] = 'RightLowerArm'; [8] = 'LeftHand'; [9] = 'RightHand'; [10] = 'LeftUpperLeg'; [11] = 'RightUpperLeg'; [12] = 'LeftLowerLeg'; [13] = 'RightLowerLeg'; [14] = 'LeftFoot'; [15] = 'RightFoot'; };
                self.Settings.Characters.Rig_parts = Rig;
            else
                Rig = { [1] = 'PrimaryPart'; };
                self.Settings.Characters.Rig_parts = Rig;
            end;
        end;
    end;

    return (#Rig == 0 and self:Get_rig() or Rig);
end;

--// Create_interface: creates the base interface. \\--

function Lucid:Create_interface()
    self.Interface.Main_window = {};
    self.UI_engine = loadstring(game:HttpGet('http://finity.vip/scripts/finity_lib.lua'))();

    --// Window. \\--

    self.Interface.Main_window.Window = self.UI_engine.new(not self.Settings.Dark_mode, 'Lucid', UDim2.new(0, 630, 0, 450));
    self.Interface.Main_window.Window.ChangeToggleKey(self.Settings.Interface.Toggle_key);

    --// Home. \\--

    self.Interface.Main_window.Home = self.Interface.Main_window.Window:Category('Home');
    self.Interface.Main_window.Home_information = self.Interface.Main_window.Home:Sector('Information');
    self.Interface.Main_window.Home_credits = self.Interface.Main_window.Home:Sector('Credits');

    --// Visuals. \\--

    self.Interface.Main_window.Visuals = self.Interface.Main_window.Window:Category('Visuals');
    self.Interface.Main_window.Visuals_settings = self.Interface.Main_window.Visuals:Sector('Settings');

    --// Visuals_settings_enabled_checkbox. \\--

    self.Interface.Main_window.Visuals_settings_enabled_checkbox = self.Interface.Main_window.Visuals_settings:Cheat(
            'Checkbox', --// Type;
            'Enabled', --// Name;
            function(State) --// Callback;
                self.Settings.Visuals.Enabled = State;
            end,
            { --// Data;
                enabled = self.Settings.Visuals.Enabled;
            }
    );

    --// Visuals_settings_check_visibility_checkbox. \\--

    self.Interface.Main_window.Visuals_settings_check_visibility_checkbox = self.Interface.Main_window.Visuals_settings:Cheat(
            'Checkbox', --// Type;
            'Check Visibility', --// Name;
            function(State) --// Callback;
                self.Settings.Visuals.Check_visibility = State;
            end,
            { --// Data;
                enabled = self.Settings.Visuals.Check_visibility;
            }
    );

    --// Visuals_settings_teams_checkbox. \\--

    self.Interface.Main_window.Visuals_settings_teams_checkbox = self.Interface.Main_window.Visuals_settings:Cheat(
            'Checkbox', --// Type;
            'Show Teams', --// Name;
            function(State) --// Callback;
                self.Settings.Visuals.Show_teams = State;
            end,
            { --// Data;
                enabled = self.Settings.Visuals.Show_teams;
            }
    );

    --// Visuals_settings_names_checkbox. \\--

    self.Interface.Main_window.Visuals_settings_names_checkbox = self.Interface.Main_window.Visuals_settings:Cheat(
            'Checkbox', --// Type;
            'Show Names', --// Name;
            function(State) --// Callback;
                self.Settings.Visuals.Show_names = State;
            end,
            { --// Data;
                enabled = self.Settings.Visuals.Names;
            }
    );

    --// Visuals_settings_distance_checkbox. \\--

    self.Interface.Main_window.Visuals_settings_distance_checkbox = self.Interface.Main_window.Visuals_settings:Cheat(
            'Checkbox', --// Type;
            'Show Distance', --// Name;
            function(State) --// Callback;
                self.Settings.Visuals.Show_distance = State;
            end,
            { --// Data;
                enabled = self.Settings.Visuals.Show_distance;
            }
    );

    --// Visuals_settings_boxes_checkbox. \\--

    self.Interface.Main_window.Visuals_settings_boxes_checkbox = self.Interface.Main_window.Visuals_settings:Cheat(
            'Checkbox', --// Type;
            'Show Boxes', --// Name;
            function(State) --// Callback;
                self.Settings.Visuals.Show_boxes = State;
            end,
            { --// Data;
                enabled = self.Settings.Visuals.Show_boxes;
            }
    );

    --// Visuals_settings_tracers_checkbox. \\--

    self.Interface.Main_window.Visuals_settings_tracers_checkbox = self.Interface.Main_window.Visuals_settings:Cheat(
            'Checkbox', --// Type;
            'Show Tracers', --// Name;
            function(State) --// Callback;
                self.Settings.Visuals.Show_tracers = State;
            end,
            { --// Data;
                enabled = self.Settings.Visuals.Show_tracers;
            }
    );

    --// Visuals_settings_tracers_offest_dropdown. \\--

    self.Interface.Main_window.Visuals_settings_tracers_offest_dropdown = self.Interface.Main_window.Visuals_settings:Cheat(
            'Dropdown', --// Type;
            'Tracers origin point', --// Name;
            function(Option) --// Callback;
                self.Settings.Visuals.Tracer_origin_point = Option;
            end,
            { --// Data;
                options = {
                    [2] = 'Top';
                    [1] = 'Center';
                    [3] = 'Bottom';
                    [4] = 'Mouse';
                };
            }
    );

    --// Visuals_settings_Head_dot_checkbox. \\--

    self.Interface.Main_window.Visuals_settings_Head_dot_checkbox = self.Interface.Main_window.Visuals_settings:Cheat(
            'Checkbox', --// Type;
            'Show Head dot', --// Name;
            function(State) --// Callback;
                self.Settings.Visuals.Show_head_dot = State;
            end,
            { --// Data;
                enabled = self.Settings.Visuals.Show_head_dot;
            }
    );

    --// Visuals_settings_text_size_slider. \\--

    self.Interface.Main_window.Visuals_settings_text_size_slider = self.Interface.Main_window.Visuals_settings:Cheat(
            'Slider', --// Type;
            'Text size', --// Name;
            function(Text_size) --// Callback;
                self.Settings.Visuals.Text_size = Text_size;
            end,
            { --// Data;
                min = 0;
                max = 100;
                suffix = '%';
            }
    );

    --// Visuals_settings_distance_slider. \\--

    self.Interface.Main_window.Visuals_settings_distance_slider = self.Interface.Main_window.Visuals_settings:Cheat(
            'Slider', --// Type;
            'Distance', --// Name;
            function(Distance) --// Callback;
                self.Settings.Visuals.Render_distance = Distance;
            end,
            { --// Data;
                min = 0;
                max = 5500;
                suffix = ' studs';
            }
    );

    --// Visuals_settings_teams_color_colorpicker. \\--

    self.Interface.Main_window.Visuals_settings_teams_color_colorpicker = self.Interface.Main_window.Visuals_settings:Cheat(
            'Colorpicker', --// Type;
            'Team color', --// Name;
            function(Color) --// Callback;
                self.Settings.Visuals.Colors.Team = Color;
            end,
            { --// Data;
                color = self.Settings.Visuals.Colors.Team;
            }
    );

    --// Visuals_settings_enemy_color_colorpicker. \\--

    self.Interface.Main_window.Visuals_settings_enemy_color_colorpicker = self.Interface.Main_window.Visuals_settings:Cheat(
            'Colorpicker', --// Type;
            'Enemy color', --// Name;
            function(Color) --// Callback;
                self.Settings.Visuals.Colors.Enemy = Color;
            end,
            { --// Data;
                color = self.Settings.Visuals.Colors.Enemy;
            }
    );

    --// Visuals_cross_hair_settings. \\--

    self.Interface.Main_window.Visuals_cross_hair_settings = self.Interface.Main_window.Visuals:Sector('Cross hair');

    --// Visuals_cross_hair_settings_cross_hair_checkbox. \\--

    self.Interface.Main_window.Visuals_cross_hair_settings_cross_hair_checkbox = self.Interface.Main_window.Visuals_cross_hair_settings:Cheat(
            'Checkbox', --// Type;
            'Enabled', --// Name;
            function(State) --// Callback;
                self.Settings.Visuals.Cross_hair = State;
            end,
            { --// Data;
                enabled = self.Settings.Visuals.Cross_hair;
            }
    );

    --// Visuals_cross_hair_settings_cross_hair_type_dropdown. \\--

    self.Interface.Main_window.Visuals_cross_hair_settings_cross_hair_type_dropdown = self.Interface.Main_window.Visuals_cross_hair_settings:Cheat(
            'Dropdown', --// Type;
            'Cross hair type', --// Name;
            function(Option) --// Callback;
                self.Settings.Visuals.Cross_hair_type = Option;
            end,
            { --// Data;
                options = self.Settings.Interface.Cross_hair_types;
            }
    );

    --// Visuals_cross_hair_settings_cross_hair_thickness_slider. \\--

    self.Interface.Main_window.Visuals_cross_hair_settings_cross_hair_thickness_slider = self.Interface.Main_window.Visuals_cross_hair_settings:Cheat(
            'Slider', --// Type;
            'Thickness', --// Name;
            function(Thickness) --// Callback;
                self.Settings.Visuals.Cross_hair_thickness = Thickness;
            end,
            { --// Data;
                min = 0;
                max = 100;
                suffix = '%';
            }
    );

    --// Visuals_cross_hair_settings_cross_hair_size_slider. \\--

    self.Interface.Main_window.Visuals_cross_hair_settings_cross_hair_size_slider = self.Interface.Main_window.Visuals_cross_hair_settings:Cheat(
            'Slider', --// Type;
            'Size', --// Name;
            function(Size) --// Callback;
                self.Settings.Visuals.Cross_hair_size = Vector2.new(Size, Size);
            end,
            { --// Data;
                min = 0;
                max = 100;
                suffix = '%';
            }
    );

    --// Visuals_cross_hair_settings_cross_hair_color_colorpicker. \\--

    self.Interface.Main_window.Visuals_cross_hair_settings_cross_hair_color_colorpicker = self.Interface.Main_window.Visuals_cross_hair_settings:Cheat(
            'Colorpicker', --// Type;
            'Cross hair color', --// Name;
            function(Color) --// Callback;
                self.Settings.Visuals.Colors.Cross_hair = Color;
            end,
            { --// Data;
                color = self.Settings.Visuals.Colors.Cross_hair;
            }
    );

    --// Aim_bot. \\--

    self.Interface.Main_window.Aim_bot = self.Interface.Main_window.Window:Category('Aimbot');
    self.Interface.Main_window.Aim_bot_settings = self.Interface.Main_window.Aim_bot:Sector('Settings');

    --// Aim_bot_settings_enabled_checkbox. \\--

    self.Interface.Main_window.Aim_bot_settings_enabled_checkbox = self.Interface.Main_window.Aim_bot_settings:Cheat(
            'Checkbox', --// Type;
            'Enabled', --// Name;
            function(State) --// Callback;
                self.Settings.Aim_bot.Enabled = State;
            end,
            { --// Data;
                enabled = self.Settings.Aim_bot.Enabled;
            }
    );

    --// Aim_bot_settings_check_visibility_checkbox. \\--

    self.Interface.Main_window.Aim_bot_settings_check_visibility_checkbox = self.Interface.Main_window.Aim_bot_settings:Cheat(
            'Checkbox', --// Type;
            'Check visibility', --// Name;
            function(State) --// Callback;
                self.Settings.Aim_bot.Check_visibility = State;
            end,
            { --// Data;
                enabled = self.Settings.Aim_bot.Check_visibility;
            }
    );

    --// Aim_bot_settings_free_for_all_checkbox. \\--

    self.Interface.Main_window.Aim_bot_settings_free_for_all_checkbox = self.Interface.Main_window.Aim_bot_settings:Cheat(
            'Checkbox', --// Type;
            'Free for all', --// Name;
            function(State) --// Callback;
                self.Settings.Aim_bot.Free_for_all = State;
            end,
            { --// Data;
                enabled = self.Settings.Aim_bot.Free_for_all;
            }
    );

    --// Aim_bot_settings_bullet_drop_checkbox. \\--

    self.Interface.Main_window.Aim_bot_settings_bullet_drop_checkbox = self.Interface.Main_window.Aim_bot_settings:Cheat(
            'Checkbox', --// Type;
            'Bullet drop compensation', --// Name;
            function(State) --// Callback;
                self.Settings.Aim_bot.Bullet_drop = State;
            end,
            { --// Data;
                enabled = self.Settings.Aim_bot.Bullet_drop;
            }
    );

    --// Aim_bot_settings_bullet_speed_textbox. \\--

    self.Interface.Main_window.Aim_bot_settings_bullet_speed_textbox = self.Interface.Main_window.Aim_bot_settings:Cheat(
            'Textbox', --// Type;
            'Bullet speed', --// Name;
            function(Value) --// Callback;
                self.Settings.Aim_bot.Bullet_speed = tonumber(Value);
            end,
            { --// Data;
                placeholder = self.Settings.Aim_bot.Bullet_speed;
            }
    );

    --// Aim_bot_settings_sensitivity_slider. \\--

    self.Interface.Main_window.Aim_bot_settings_sensitivity_slider = self.Interface.Main_window.Aim_bot_settings:Cheat(
            'Slider', --// Type;
            'Sensitivity', --// Name;
            function(Value) --// Callback;
                self.Settings.Aim_bot.Sensitivity.Current = (Value / 100);
            end,
            { --// Data;
                min = self.Settings.Aim_bot.Sensitivity.Min;
                max = self.Settings.Aim_bot.Sensitivity.Max;
                suffix = '%';
            }
    );

    --// Aim_bot_settings_offset_label. \\--

    self.Interface.Main_window.Aim_bot_settings_offset_label = self.Interface.Main_window.Aim_bot_settings:Cheat(
            'Label', --// Type;
            'Aim offset' --// Name;
    );

    --// Aim_bot_settings_offset_x_textbox. \\--

    self.Interface.Main_window.Aim_bot_settings_offset_x_textbox = self.Interface.Main_window.Aim_bot_settings:Cheat(
            'Textbox', --// Type;
            'X', --// Name;
            function(Value) --// Callback;
                self.Settings.Aim_bot.Aim_offset = Vector3.new(tonumber(Value) or self.Settings.Aim_bot.Aim_offset.X, self.Settings.Aim_bot.Aim_offset.Y, self.Settings.Aim_bot.Aim_offset.Z);
            end,
            { --// Data;
                placeholder = self.Settings.Aim_bot.Aim_offset.X;
            }
    );

    --// Aim_bot_settings_offset_y_textbox. \\--

    self.Interface.Main_window.Aim_bot_settings_offset_y_textbox = self.Interface.Main_window.Aim_bot_settings:Cheat(
            'Textbox', --// Type;
            'Y', --// Name;
            function(Value) --// Callback;
                self.Settings.Aim_bot.Aim_offset = Vector3.new(self.Settings.Aim_bot.Aim_offset.X, tonumber(Value) or self.Settings.Aim_bot.Aim_offset.Y, self.Settings.Aim_bot.Aim_offset.Z);
            end,
            { --// Data;
                placeholder = self.Settings.Aim_bot.Aim_offset.Y;
            }
    );

    --// Aim_bot_settings_offset_y_textbox. \\--

    self.Interface.Main_window.Aim_bot_settings_offset_y_textbox = self.Interface.Main_window.Aim_bot_settings:Cheat(
            'Textbox', --// Type;
            'Z', --// Name;
            function(Value) --// Callback;
                self.Settings.Aim_bot.Aim_offset = Vector3.new(self.Settings.Aim_bot.Aim_offset.X, self.Settings.Aim_bot.Aim_offset.Y, tonumber(Value) or self.Settings.Aim_bot.Aim_offset.Z);
            end,
            { --// Data;
                placeholder = self.Settings.Aim_bot.Aim_offset.Z;
            }
    );

    --// Aim_bot_settings_aim_at_dropdown. \\--

    self.Interface.Main_window.Aim_bot_settings_aim_at_dropdown = self.Interface.Main_window.Aim_bot_settings:Cheat(
            'Dropdown', --// Type;
            'Priority', --// Name;
            function(Option) --// Callback;
                self.Settings.Aim_bot.Aim_at = Option;
            end,
            { --// Data;
                options = self:Get_rig();
            }
    );

    --// Settings. \\--

    self.Interface.Main_window.Settings = self.Interface.Main_window.Window:Category('Settings');
    self.Interface.Main_window.Settings_window = self.Interface.Main_window.Settings:Sector('Window');

    --// Settings_window_toggle_key. \\--

    self.Interface.Main_window.Settings_window_toggle_key = self.Interface.Main_window.Settings_window:Cheat(
            'keybind', --// Type;
            'Toggle key', --// Name;
            function(Key) --// Callback;
                self.Settings.Interface.Toggle_key = Key;
                self.Interface.Main_window.Window.ChangeToggleKey(self.Settings.Interface.Toggle_key);
            end,
            { --// Data;
                bind = self.Settings.Interface.Toggle_key;
            }
    );

    --// Settings_window_theme_dropdown. \\--

    self.Interface.Main_window.Settings_window_theme_dropdown = self.Interface.Main_window.Settings_window:Cheat(
            'Dropdown', --// Type;
            'Theme (coming soon.)', --// Name;
            function(Option) --// Callback;
                self.Settings.Interface.Dark_mode = (Option == 'Dark');
            end,
            { --// Data;
                options = self.Settings.Interface.Theme_options;
            }
    );
end;

--// Visuals: Starts up the visuals. \\--

function Lucid:Visuals()
    local Visuals = {};
    Visuals.Mouse = self:Mouse();
    Visuals.Camera = self:Camera();
    Visuals.Player = self:Player();
    Visuals.Services = self.Services;
    Visuals.Settings = self.Settings;
    Visuals.Interface = self.Interface;
    Visuals.Character = nil;
    Visuals.Environment = self:Environment();
    Visuals.Cross_hair_types = {
        Cross = {
            X = self:Drawing('Line');
            Y = self:Drawing('Line');
        };

        Circle = {
            Circle = self:Drawing('Circle');
        };
    };
    Visuals.Showing = { Tracers = {}; Names = {}; Distances = {}; Boxes = {}; Head_dots = {}; };

    --// Create_box. \\--

    function Visuals:Create_box()
        local New_box = {};
        New_box.Sides = {};

        --// Sides. \\--

        New_box.Sides.Top = Lucid:Drawing('Line');
        New_box.Sides.Bottom = Lucid:Drawing('Line');
        New_box.Sides.Right = Lucid:Drawing('Line');
        New_box.Sides.Left = Lucid:Drawing('Line');

        --// Modify. \\--

        function New_box:Modify(_CFrame, Size, New_properties)
            _CFrame = _CFrame or CFrame.new();
            Size = Size or Vector3.new(0, 0, 0);
            New_properties = New_properties or {};

            local TLPos, Visible1 = Visuals.Camera:WorldToViewportPoint((_CFrame * CFrame.new(Size.X,  Size.Y, 0)).p);
            local TRPos, Visible2 = Visuals.Camera:WorldToViewportPoint((_CFrame * CFrame.new(-Size.X,  Size.Y, 0)).p);
            local BLPos, Visible3 = Visuals.Camera:WorldToViewportPoint((_CFrame * CFrame.new(Size.X, -Size.Y, 0)).p);
            local BRPos, Visible4 = Visuals.Camera:WorldToViewportPoint((_CFrame * CFrame.new(-Size.X, -Size.Y, 0)).p);

            Visible1 = TLPos.Z > 0;
            Visible2 = TRPos.Z > 0;
            Visible3 = BLPos.Z > 0;
            Visible4 = BRPos.Z > 0;

            self.Sides.Top:Modify('Visible', Visible1);
            self.Sides.Top:Modify('From', (Visible1 and Vector2.new(TLPos.X, TLPos.Y) or Vector2.new(0, 0)));
            self.Sides.Top:Modify('To', (Visible1 and Vector2.new(TRPos.X, TRPos.Y) or Vector2.new(0, 0)));

            self.Sides.Bottom:Modify('Visible', Visible2);
            self.Sides.Bottom:Modify('From', (Visible2 and Vector2.new(TRPos.X, TRPos.Y) or Vector2.new(0, 0)));
            self.Sides.Bottom:Modify('To', (Visible2 and Vector2.new(BRPos.X, BRPos.Y) or Vector2.new(0, 0)));

            self.Sides.Right:Modify('Visible', Visible3);
            self.Sides.Right:Modify('From', (Visible3 and Vector2.new(BLPos.X, BLPos.Y) or Vector2.new(0, 0)));
            self.Sides.Right:Modify('To', (Visible3 and Vector2.new(TLPos.X, TLPos.Y) or Vector2.new(0, 0)));

            self.Sides.Left:Modify('Visible', Visible4);
            self.Sides.Left:Modify('From', (Visible3 and Vector2.new(BRPos.X, BRPos.Y) or Vector2.new(0, 0)));
            self.Sides.Left:Modify('To', (Visible3 and Vector2.new(BLPos.X, BLPos.Y) or Vector2.new(0, 0)));

            for Property, Value in pairs(New_properties) do
                self.Sides.Top:Modify(Property, Value);
                self.Sides.Bottom:Modify(Property, Value);

                self.Sides.Right:Modify(Property, Value);
                self.Sides.Left:Modify(Property, Value);
            end;
        end;

        --// Remove. \\--

        function New_box:Remove()
            self.Sides.Top:Remove();
            self.Sides.Bottom:Remove();

            self.Sides.Right:Remove();
            self.Sides.Left:Remove();
            self = nil;
        end;

        return New_box;
    end;

    --// Cross. \\--

    Visuals.Cross_hair_types.Cross.X:Modify('To', Vector2.new((Visuals.Camera.ViewportSize.X / 2) - self.Settings.Visuals.Cross_hair_size.X, (Visuals.Camera.ViewportSize.Y / 2)));
    Visuals.Cross_hair_types.Cross.X:Modify('From', Vector2.new((Visuals.Camera.ViewportSize.X / 2) + self.Settings.Visuals.Cross_hair_size.X, (Visuals.Camera.ViewportSize.Y / 2)));

    Visuals.Cross_hair_types.Cross.Y:Modify('To', Vector2.new((Visuals.Camera.ViewportSize.X / 2), (Visuals.Camera.ViewportSize.Y / 2) - self.Settings.Visuals.Cross_hair_size.X));
    Visuals.Cross_hair_types.Cross.Y:Modify('From', Vector2.new((Visuals.Camera.ViewportSize.X / 2), (Visuals.Camera.ViewportSize.Y / 2) + self.Settings.Visuals.Cross_hair_size.X));

    --// Circle. \\--

    Visuals.Cross_hair_types.Circle.Circle:Modify('Position', Vector2.new(Visuals.Camera.ViewportSize.X / 2, Visuals.Camera.ViewportSize.Y / 2));
    Visuals.Cross_hair_types.Circle.Circle:Modify('Filled', false);

    --// Showing. \\--

    for Index = 1, self.Services.Players.MaxPlayers do

        --// Tracers. \\--

        Visuals.Showing.Tracers[Index] = { Line = self:Drawing('Line'); };
        Visuals.Showing.Tracers[Index].Line:Modify('Color', self.Settings.Visuals.Colors.Enemy);
        Visuals.Showing.Tracers[Index].Line:Modify('Thickness', .1);
        Visuals.Showing.Tracers[Index].Line:Modify('Visible', false);

        --// Names. \\--

        Visuals.Showing.Names[Index] = { Text = self:Drawing('Text'); };
        Visuals.Showing.Names[Index].Text:Modify('Color', self.Settings.Visuals.Colors.Enemy);
        Visuals.Showing.Names[Index].Text:Modify('Size', (32 / (100 / self.Settings.Visuals.Text_size)));
        Visuals.Showing.Names[Index].Text:Modify('Center', true);
        Visuals.Showing.Names[Index].Text:Modify('Visible', false);

        --// Distances. \\--

        Visuals.Showing.Distances[Index] = { Text = self:Drawing('Text'); };
        Visuals.Showing.Distances[Index].Text:Modify('Color', self.Settings.Visuals.Colors.Enemy);
        Visuals.Showing.Distances[Index].Text:Modify('Size', (32 / (100 / self.Settings.Visuals.Text_size)));
        Visuals.Showing.Distances[Index].Text:Modify('Center', true);
        Visuals.Showing.Distances[Index].Text:Modify('Visible', false);

        --// Boxes. \\--

        Visuals.Showing.Boxes[Index] = { Square = Visuals:Create_box(); };
        Visuals.Showing.Boxes[Index].Square:Modify(nil, Vector3.new(2, 3, 0), { ['Color'] = self.Settings.Visuals.Colors.Enemy; });
        Visuals.Showing.Boxes[Index].Square:Modify(nil, Vector3.new(2, 3, 0), { ['Visible'] = false; });

        --// Head_dots. \\--

        Visuals.Showing.Head_dots[Index] = { Circle = self:Drawing('Circle'); };
        Visuals.Showing.Head_dots[Index].Circle:Modify('Thickness', .1);
        Visuals.Showing.Head_dots[Index].Circle:Modify('Radius', 4);
        Visuals.Showing.Head_dots[Index].Circle:Modify('NumSides', 12);
        Visuals.Showing.Head_dots[Index].Circle:Modify('Color', self.Settings.Visuals.Colors.Enemy);
        Visuals.Showing.Head_dots[Index].Circle:Modify('Visible', false);
        Visuals.Showing.Head_dots[Index].Circle:Modify('Filled', false);

    end;

    --// Check_visibility. \\--

    function Visuals:Check_visibility(Point, Descendant, Ignore_list)
        local Origin = self.Camera.CFrame.p;
        local Distance = (Origin - Point).Magnitude;
        local Vector, On_screen = self.Camera:WorldToViewportPoint(Point);
        local Object_position = self.Camera.CFrame:pointToObjectSpace(Point);

        if Vector.Z < 0 then
            local AT = math.atan2(Object_position.Y, Object_position.X) + math.pi;
            Object_position = CFrame.Angles(0, 0, AT):vectorToWorldSpace((CFrame.Angles(0, math.rad(89.9), 0):vectorToWorldSpace(Vector3.new(0, 0, -1))));
        end

        Object_position = self.Camera:WorldToViewportPoint(self.Camera.CFrame:pointToWorldSpace(Object_position));

        if On_screen then
            local _Ray = Ray.new(Origin, Point - Origin);
            local Hit, _ = self.Services.Workspace:FindPartOnRayWithIgnoreList(_Ray, Ignore_list or {});
            local Visible = (not Hit or Hit:IsDescendantOf(Descendant));

            return Visible, Vector, Object_position, Distance;
        else
            return false, Vector, Object_position, Distance;
        end;
    end;

    --// Get_players. \\--

    function Visuals:Get_players(Offset)
        local Players = {};
        Offset = Offset or Vector3.new(0, 0, 0);

        if self.Character and self.Character.PrimaryPart then
            for _, Player in pairs(self.Services.Players:GetPlayers()) do
                local Character = Player.Character;

                if Character and Character:IsDescendantOf(self.Services.Workspace) and Character ~= self.Character then
                    local Visible, Screen_position, Object_position, Distance = self:Check_visibility(Character.PrimaryPart.Position + Offset, Character, { self.Services.Workspace:FindFirstChild('Ignore'); self.Character; self.Camera; });

                    if Distance <= self.Settings.Visuals.Render_distance then
                        if self.Settings.Visuals.Show_teams then
                            if Screen_position then
                                Players[#Players + 1] = { Player = Player; PrimaryPart = Character.PrimaryPart; Visible = (not self.Settings.Visuals.Check_visibility or Visible); Object_position = Object_position; Screen_position = Screen_position; Distance = Distance; Color = ((Player.Team ~= self.Player.Team or Player.TeamColor ~= self.Player.TeamColor) and self.Settings.Visuals.Colors.Enemy or self.Settings.Visuals.Colors.Team); };
                            end;
                        elseif not self.Settings.Visuals.Show_teams and (Player.Team ~= self.Player.Team or Player.TeamColor ~= self.Player.TeamColor) then
                            if Screen_position then
                                Players[#Players + 1] = { Player = Player; PrimaryPart = Character.PrimaryPart; Visible = (not self.Settings.Visuals.Check_visibility or Visible); Object_position = Object_position; Screen_position = Screen_position; Distance = Distance; Color = ((Player.Team ~= self.Player.Team or Player.TeamColor ~= self.Player.TeamColor) and self.Settings.Visuals.Colors.Enemy or self.Settings.Visuals.Colors.Team); };
                            end;
                        end;
                    end;
                end;
            end;
        end;

        return Players;
    end;

    --// Cross_hair. \\--

    function Visuals:Cross_hair()
        if self.Settings.Visuals.Cross_hair then
            if self.Settings.Visuals.Cross_hair_type == 'Cross' then
                self.Cross_hair_types.Circle.Circle:Modify('Visible', false);

                self.Cross_hair_types.Cross.X:Modify('Thickness', self.Settings.Visuals.Cross_hair_thickness);
                self.Cross_hair_types.Cross.X:Modify('Visible', true);
                self.Cross_hair_types.Cross.X:Modify('Color', self.Settings.Visuals.Colors.Cross_hair);

                self.Cross_hair_types.Cross.Y:Modify('Thickness', self.Settings.Visuals.Cross_hair_thickness);
                self.Cross_hair_types.Cross.Y:Modify('Visible', true);
                self.Cross_hair_types.Cross.Y:Modify('Color', self.Settings.Visuals.Colors.Cross_hair);

                self.Cross_hair_types.Cross.X:Modify('To', Vector2.new((self.Camera.ViewportSize.X / 2) - self.Settings.Visuals.Cross_hair_size.X, (self.Camera.ViewportSize.Y / 2)));
                self.Cross_hair_types.Cross.X:Modify('From', Vector2.new((self.Camera.ViewportSize.X / 2) + self.Settings.Visuals.Cross_hair_size.X, (self.Camera.ViewportSize.Y / 2)));

                self.Cross_hair_types.Cross.Y:Modify('To', Vector2.new((self.Camera.ViewportSize.X / 2), (self.Camera.ViewportSize.Y / 2) - self.Settings.Visuals.Cross_hair_size.X));
                self.Cross_hair_types.Cross.Y:Modify('From', Vector2.new((self.Camera.ViewportSize.X / 2), (self.Camera.ViewportSize.Y / 2) + self.Settings.Visuals.Cross_hair_size.X));
            elseif self.Settings.Visuals.Cross_hair_type == 'Circle' then
                self.Cross_hair_types.Cross.X:Modify('Visible', false);
                self.Cross_hair_types.Cross.Y:Modify('Visible', false);

                self.Cross_hair_types.Circle.Circle:Modify('Thickness', self.Settings.Visuals.Cross_hair_thickness);

                self.Cross_hair_types.Circle.Circle:Modify('Radius', self.Settings.Visuals.Cross_hair_size.X);
                self.Cross_hair_types.Circle.Circle:Modify('NumSides', math.floor(self.Settings.Visuals.Cross_hair_size.X / 4));

                self.Cross_hair_types.Circle.Circle:Modify('Visible', true);
                self.Cross_hair_types.Circle.Circle:Modify('Color', self.Settings.Visuals.Colors.Cross_hair);
            end;
        else
            self.Cross_hair_types.Cross.X:Modify('Visible', false);
            self.Cross_hair_types.Cross.Y:Modify('Visible', false);
            self.Cross_hair_types.Circle.Circle:Modify('Visible', false);
        end;
    end;

    --// Tracers. \\--

    function Visuals:Tracers()
        if self.Settings.Visuals.Show_tracers then
            local Players = self:Get_players();

            for Index, Tracer in pairs(self.Showing.Tracers) do
                local Assigned = Players[Index];
                local Mouse_position_2d = Vector2.new(self.Mouse.X, self.Mouse.Y) + Vector2.new(0, 33);

                if Assigned then
                    Tracer.Line:Modify('Visible', Assigned.Visible);
                    Tracer.Line:Modify('From', (self.Settings.Visuals.Tracer_origin_point == 'Top' and Vector2.new((Visuals.Camera.ViewportSize.X / 2), 0) or self.Settings.Visuals.Tracer_origin_point == 'Center' and Vector2.new((Visuals.Camera.ViewportSize.X / 2), (Visuals.Camera.ViewportSize.Y / 2)) or self.Settings.Visuals.Tracer_origin_point == 'Bottom' and Vector2.new((Visuals.Camera.ViewportSize.X / 2), (self.Services.CoreGui.RobloxGui.AbsoluteSize.Y + 32)) or self.Settings.Visuals.Tracer_origin_point == 'Mouse' and Mouse_position_2d));
                    Tracer.Line:Modify('To', Vector2.new(Assigned.Object_position.X, Assigned.Object_position.Y));
                    Tracer.Line:Modify('Color', Assigned.Color);
                else
                    Tracer.Line:Modify('Visible', false);
                end;
            end;
        else
            for Index, Tracer in pairs(self.Showing.Tracers) do
                Tracer.Line:Modify('Visible', false);
            end;
        end;
    end;

    --// Names. \\--

    function Visuals:Names()
        if self.Settings.Visuals.Show_names then
            local Players = self:Get_players(Vector3.new(0, 3, 0));

            for Index, Name in pairs(self.Showing.Names) do
                local Assigned = Players[Index];

                if Assigned then
                    Name.Text:Modify('Text', Assigned.Player.Name);
                    Name.Text:Modify('Position', Vector2.new(Assigned.Object_position.X, Assigned.Object_position.Y - (self.Settings.Visuals.Show_names and (32 / (100 / self.Settings.Visuals.Text_size)) or 0)));
                    Name.Text:Modify('Size', (32 / (100 / self.Settings.Visuals.Text_size)));
                    Name.Text:Modify('Color', Assigned.Color);
                    Name.Text:Modify('Visible', Assigned.Visible);
                else
                    Name.Text:Modify('Visible', false);
                end;
            end;
        else
            for Index, Name in pairs(self.Showing.Names) do
                Name.Text:Modify('Visible', false);
            end;
        end;
    end;

    --// Distance. \\--

    function Visuals:Distance()
        if self.Settings.Visuals.Show_distance then
            local Players = self:Get_players(Vector3.new(0, 3, 0));

            for Index, Distance in pairs(self.Showing.Distances) do
                local Assigned = Players[Index];

                if Assigned then
                    Distance.Text:Modify('Position', Vector2.new(Assigned.Object_position.X, Assigned.Object_position.Y));
                    Distance.Text:Modify('Text', string.format('%s studs', tostring(math.floor(Assigned.Distance))));
                    Distance.Text:Modify('Size', (32 / (100 / self.Settings.Visuals.Text_size)));
                    Distance.Text:Modify('Color', Assigned.Color);
                    Distance.Text:Modify('Visible', Assigned.Visible);
                else
                    Distance.Text:Modify('Visible', false);
                end;
            end;
        else
            for Index, Distance in pairs(self.Showing.Distances) do
                Distance.Text:Modify('Visible', false);
            end;
        end;
    end;

    --// Boxes. \\--

    function Visuals:Boxes()
        if self.Settings.Visuals.Show_boxes then
            local Players = self:Get_players();

            for Index, Box in pairs(self.Showing.Boxes) do
                local Assigned = Players[Index];

                if Assigned then
                    Box.Square:Modify((Assigned.PrimaryPart ~= nil and Assigned.PrimaryPart.CFrame * CFrame.new(0, -2, 0) or nil), Vector3.new(2, 3, 0), { Visible = Assigned.Visible; Color = Assigned.Color; });
                else
                    Box.Square:Modify(nil, Vector3.new(2, 3, 0), { Visible = false; });
                end;
            end;
        else
            for Index, Box in pairs(self.Showing.Boxes) do
                Box.Square:Modify(nil, Vector3.new(2, 3, 0), { Visible = false; });
            end;
        end;
    end;

    --// Head_dot. \\--

    function Visuals:Head_dot()
        if self.Settings.Visuals.Show_head_dot then
            local Players = self:Get_players();

            for Index, Head_dot in pairs(self.Showing.Head_dots) do
                local Assigned = Players[Index];

                if Assigned then
                    Head_dot.Circle:Modify('Position', Vector2.new(Assigned.Object_position.X, Assigned.Object_position.Y));
                    Head_dot.Circle:Modify('Color', Assigned.Color);
                    Head_dot.Circle:Modify('Visible', Assigned.Visible);
                else
                    Head_dot.Circle:Modify('Visible', false);
                end;
            end;
        else
            for Index, Head_dot in pairs(self.Showing.Head_dots) do
                Head_dot.Circle:Modify('Visible', false);
            end;
        end;
    end;

    --// Update. \\--

    function Visuals:Update()
        self.Character = self.Player.Character;

        self:Cross_hair();
        self:Tracers();
        self:Names();
        self:Distance();
        self:Boxes();
        self:Head_dot();
    end;

    self.Services.RunService.RenderStepped:Connect(function() Visuals:Update(); end);
end;

--// Aimbot: Starts up the aimbot. \\--

function Lucid:Aimbot()
    local Aimbot = {};
    Aimbot.Aim_hex_size = 6;
    Aimbot.Mouse = self:Mouse();
    Aimbot.Camera = self:Camera();
    Aimbot.Player = self:Player();
    Aimbot.Services = self.Services;
    Aimbot.Settings = self.Settings;
    Aimbot.Interface = self.Interface;
    Aimbot.Interface_visible = true;
    Aimbot.Character = nil;
    Aimbot.Aim_hex_size_transition = 'Out';
    Aimbot.Environment = self:Environment();
    Aimbot.Aim_hex = self:Drawing('Circle');
    Aimbot.Guns = setmetatable({ Cache = {}; }, { __index = function(self, Gun_name) local Gun_modules = Aimbot.Services.ReplicatedStorage:FindFirstChild('GunModules'); if Gun_modules then self.Cache[Gun_name] = self.Cache[Gun_name] or (Gun_modules:FindFirstChild(Gun_name) and require(Gun_modules:FindFirstChild(Gun_name))); return self.Cache[Gun_name]; end; end; });

    --// Aim_hex. \\--

    Aimbot.Aim_hex:Modify('Color', Color3.fromRGB(255, 255, 255));
    Aimbot.Aim_hex:Modify('Thickness', .1);
    Aimbot.Aim_hex:Modify('NumSides', Aimbot.Aim_hex_size);
    Aimbot.Aim_hex:Modify('Radius', Aimbot.Aim_hex_size);
    Aimbot.Aim_hex:Modify('Visible', false);
    Aimbot.Aim_hex:Modify('Filled', false);

    --// Find_bullet_speed. \\--


    function Aimbot:Find_bullet_speed()
        for _, Object in pairs(self.Camera:GetChildren()) do
            if Object.Name ~= 'Left Arm' and Object.Name ~= 'Right Arm' then
                local Gun = self.Guns[Object.Name];

                if Gun then
                    return Gun.bulletspeed;
                end;
            end;
        end;

        return nil;
    end;

    --// Get_bullet_speed. \\--

    function Aimbot:Get_bullet_speed()
        local Bullet_speed = self.Settings.Aim_bot.Bullet_speed;

        --// Phantom Forces. \\--

        if game.PlaceId == 292439477 then
            Bullet_speed = self:Find_bullet_speed() or self.Settings.Aim_bot.Bullet_speed;
        end;

        self.Interface.Main_window.Aim_bot_settings_bullet_speed_textbox.textbox.Text = Bullet_speed;

        return Bullet_speed;
    end;

    --// Check_visibility. \\--

    function Aimbot:Check_visibility(Point, Descendant, Ignore_list)
        local Origin = self.Camera.CFrame.p;
        local Distance = (Origin - Point).Magnitude;
        local Vector, On_screen = self.Camera:WorldToViewportPoint(Point);
        local Object_position = self.Camera.CFrame:pointToObjectSpace(Point);

        if Vector.Z < 0 then
            local AT = math.atan2(Object_position.Y, Object_position.X) + math.pi;
            Object_position = CFrame.Angles(0, 0, AT):vectorToWorldSpace((CFrame.Angles(0, math.rad(89.9), 0):vectorToWorldSpace(Vector3.new(0, 0, -1))));
        end

        Object_position = self.Camera:WorldToViewportPoint(self.Camera.CFrame:pointToWorldSpace(Object_position));

        if On_screen then
            local _Ray = Ray.new(Origin, Point - Origin);
            local Hit, _ = self.Services.Workspace:FindPartOnRayWithIgnoreList(_Ray, Ignore_list or {});
            local Visible = (not Hit or Hit:IsDescendantOf(Descendant));

            return Visible, Vector, Object_position, Distance;
        else
            return false, Vector, Object_position, Distance;
        end;
    end;

    --// Find_closest_player. \\--

    function Aimbot:Find_closest_player()
        local Players = {};
        local Distances = {};

        if self.Character and self.Character.PrimaryPart then
            for _, Player in pairs(self.Services.Players:GetPlayers()) do
                if (not self.Settings.Aim_bot.Free_for_all and (Player.Team ~= self.Player.Team or Player.TeamColor ~= self.Player.TeamColor)) then
                    local Character = Player.Character;

                    if Character and Character:IsDescendantOf(self.Services.Workspace) and Character ~= self.Character then
                        local Aim_at = Character:FindFirstChild((self.Settings.Aim_bot.Aim_at == 'PrimaryPart' and 'HumanoidRootPart' or self.Settings.Aim_bot.Aim_at));

                        if Aim_at then
                            local Visible, Screen_position, Object_position, Distance = self:Check_visibility(Aim_at.Position + self.Settings.Aim_bot.Aim_offset, Character, { self.Services.Workspace:FindFirstChild('Ignore'); self.Character; self.Camera; });

                            if (self.Settings.Aim_bot.Check_visibility and Visible and Screen_position) then
                                Players[#Players + 1] = math.floor(Distance);
                                Distances[math.floor(Distance)] = { Player = Player; Character = Character; Object_position = Object_position; Screen_position = Screen_position; };
                            elseif not (self.Settings.Aim_bot.Check_visibility and Screen_position) then
                                Players[#Players + 1] = math.floor(Distance);
                                Distances[math.floor(Distance)] = { Player = Player; Character = Character; Object_position = Object_position; Screen_position = Screen_position; };
                            end;
                        end;
                    end;
                elseif (self.Settings.Aim_bot.Free_for_all) then
                    local Character = Player.Character;

                    if Character and Character:IsDescendantOf(self.Services.Workspace) and Character ~= self.Character then
                        local Aim_at = Character:FindFirstChild((self.Settings.Aim_bot.Aim_at == 'PrimaryPart' and 'HumanoidRootPart' or self.Settings.Aim_bot.Aim_at));

                        if Aim_at then
                            local Visible, Screen_position, Object_position, Distance = self:Check_visibility(Aim_at.Position + self.Settings.Aim_bot.Aim_offset, Character, { self.Services.Workspace:FindFirstChild('Ignore'); self.Character; self.Camera; });

                            if (self.Settings.Aim_bot.Check_visibility and Visible and Screen_position) then
                                Players[#Players + 1] = math.floor(Distance);
                                Distances[math.floor(Distance)] = { Player = Player; Character = Character; Object_position = Object_position; Screen_position = Screen_position; };
                            elseif not (self.Settings.Aim_bot.Check_visibility and Screen_position) then
                                Players[#Players + 1] = math.floor(Distance);
                                Distances[math.floor(Distance)] = { Player = Player; Character = Character; Object_position = Object_position; Screen_position = Screen_position; };
                            end;
                        end;
                    end;
                end;
            end;
        end;

        return (#Players > 0 and Distances[math.min(unpack(Players))]) or nil;
    end;

    --// Update. \\--

    function Aimbot:Update()
        if self.Settings.Aim_bot.Enabled and self.Settings.Aim_bot.Aiming_down then
            self.Character = self.Player.Character;

            if self.Character then
                local Closest_player = self:Find_closest_player();

                if Closest_player then
                    local Player = Closest_player.Player;
                    local Character = Closest_player.Character;
                    local Screen_position = Closest_player.Screen_position;
                    local Object_position = Closest_player.Object_position;
                    local Sensitivity = math.clamp(self.Settings.Aim_bot.Sensitivity.Current, 0, 1) * .5;
                    local Screen_position_2d = Vector2.new(Object_position.X, Object_position.Y);
                    local Mouse_position_2d = Vector2.new(self.Mouse.ViewSizeX, self.Mouse.ViewSizeY);
                    local Relative_position = Screen_position_2d - Mouse_position_2d / 2;
                    local max_magnitude = math.min(Relative_position.Magnitude, 150);

                    Relative_position = Relative_position.unit * max_magnitude * Sensitivity;

                    self.Aim_hex_size = (self.Aim_hex_size_transition == 'Out' and self.Aim_hex_size + 1) or (self.Aim_hex_size_transition == 'In' and self.Aim_hex_size - 1) or 6;
                    self.Aim_hex_size_transition = (self.Aim_hex_size_transition == 'Out' and self.Aim_hex_size > 20 and 'In' or self.Aim_hex_size_transition == 'In' and self.Aim_hex_size < 6 and 'Out');

                    self.Aim_hex:Modify('Position', Screen_position_2d);
                    self.Aim_hex:Modify('Visible', true);
                    self.Aim_hex:Modify('Radius', self.Aim_hex_size);

                    self.Environment.Interactions.Mouse.Move_relative(Relative_position.X, Relative_position.Y);
                else
                    self.Aim_hex:Modify('Visible', false);
                end;
            else
                self.Aim_hex:Modify('Visible', false);
            end;
        else
            self.Aim_hex:Modify('Visible', false);
        end;
    end;

    --// InputBegan. \\--

    function Aimbot:InputBegan(Input_Information, Game_Processed)
        local Input_key = Input_Information.KeyCode;
        local Input_Type = Input_Information.UserInputType;

        if Input_Type == Enum.UserInputType.MouseButton2 then
            self.Settings.Aim_bot.Aiming_down = true;
        elseif Input_key == self.Settings.Interface.Toggle_key then
            self.Interface_visible = not self.Interface_visible;
            self.Services.UserInputService.OverrideMouseIconBehavior = (self.Interface_visible and Enum.OverrideMouseIconBehavior.ForceShow or Enum.OverrideMouseIconBehavior.None);
        end;
    end;

    --// InputEnded. \\--

    function Aimbot:InputEnded(Input_Information, Game_Processed)
        local Input_key = Input_Information.KeyCode;
        local Input_Type = Input_Information.UserInputType;

        if Input_Type == Enum.UserInputType.MouseButton2 then
            self.Settings.Aim_bot.Aiming_down = false;
        end;
    end;

    self.Services.UserInputService.InputBegan:Connect(function(Input_Information, Game_Processed) Aimbot:InputBegan(Input_Information, Game_Processed); end);
    self.Services.UserInputService.InputEnded:Connect(function(Input_Information, Game_Processed) Aimbot:InputEnded(Input_Information, Game_Processed); end);
    self.Services.RunService.RenderStepped:Connect(function() Aimbot:Update(); end);
end;

--// Init: Starts up the lucid. \\--

function Lucid:Init()
    self.Init = nil;

    if not getgenv().Lucid then
        getgenv().Lucid = true;
        self:Game_synced();
        self:Visuals();
        self:Aimbot();
        self:Create_interface();
    end;

    return self;
end;

return Lucid:Init();
